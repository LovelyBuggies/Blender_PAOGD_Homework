# Tank War

<p align="center">
<img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4ym4sws67j318a0osgqc.jpg" alt="ScoreChain" title="ScoreChain" length = "1400" width="500"/><br/>
</p>
<p align="center">
<a href="https://gitee.com/code_sysu/syllabus/blob/master/Lectures/PAOGD%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB%E9%A1%BA%E5%BA%8F.xlsx"><img src="https://img.shields.io/badge/team-17-aa3333.svg"></a>
<a href="https://www.youtube.com/watch?v=itYok4eUv3A"><img src="https://img.shields.io/badge/theme-tank war-00aace.svg"></a>
<a href="https://gitee.com/paogdfenzu10/GroupProject"><img src="https://img.shields.io/badge/direction-sever-yellow.svg"></a>
<a href="https://gitee.com/paogdfenzu10/GroupProject"><img src="https://img.shields.io/badge/coverage-A-blue.svg"></a>
<br/><br/>
<a href="hhttps://gitee.com/paogdfenzu10/GroupProject"><img src="https://img.shields.io/appveyor/ci/gruntjs/grunt.svg"></a>
<a href="https://gitee.com/paogdfenzu10/GroupProject"><img src="https://img.shields.io/badge/platform-Win 10-a7bE6E.svg"></a>
<a href="https://gitee.com/paogdfenzu10/GroupProject"><img src="https://img.shields.io/badge/date-June~July, 2019-orange.svg"></a>
<a href="https://996.icu"><img src="https://img.shields.io/badge/link-996.icu-8855dd.svg" alt="996.icu"></a>
<br/><br/>
</p>

---

## I. 游戏简介

我们组设计的《坦克大战》，以二战坦克为题材，既保留了射击类游戏的操作性，也改进了射击类游戏太过于复杂难玩的高门槛特点，是一款集休闲与竞技于一身的游戏。提供二战知名坦克供您选择，各坦克独立个性强化系统，更拥有独特皮肤闪亮登场，让每一个玩家都能找到适合自己的归属。我们还将推出故事背景与真实战役，以及万众期待的火炮系统，传说与梦想中的坦克，一切都值得您的到来。

---

## II. 游戏玩法

- WASD控制坦克的移动；
- 游戏开始，各玩家进入场景，拥有不同的皮肤；
- 一个玩家有3次生命。被击中三次后，玩家死亡，重新进入场景；
- 坦克和发射的子弹无法穿过墙壁，必须直面其他炮火。

---

## III. 设计目标

- 完成坦克和墙壁等背景渲染，初步描绘游戏场景；
- 完成坦克大战游戏的框架搭建，实现基本的游戏操作；
- 支持多玩家比赛、信息同步；
- 实现低延时、解决抖动问题。

---

## IV. 项目部署

Win10系统中，在Visual Studio2017（*VS2019可能存在版本受限*）中打开项目目录，打开`./TankWar.sln`文件，重新生成解决方案。然后进入`./Debug`目录下，`Shift+右键`打开PowShell，进行以下操作：

```shell
$ cmd
$ TankWarSever 50000 
$ TankWarClient 127.0.0.1:50000 Alice //也可以用您自己服务器的端口
```

如果您是游戏的发起者，那么您需要执行上面的操作；如果您是参与的玩家，只需运行客户端即可。

---

## V. 游戏实现

---

<!--ToDo: 最后写一下实现概要-->

### 1. 游戏对象

游戏主要涉及三种对象，分别是子弹、墙、坦克。每个种类都有不同的属性，我们在其基类上分别添加了它们的服务器，用来管理它们在游戏中的行为。

#### 1.1. Bullet Server

Bullet Sever继承了Bullet类。实现细节如下：

- 属性
    - `mTimeToDie`：子弹消失的时间，是子弹消失1s之后消失；
- 方法
    - `StaticCreate()`：创建一颗子弹；
    - `Update()`如果超过了子弹生命周期，子弹消失，并更新画面；
    - `HandleCollisionWithTank(Tank* inTank)`：当子弹碰到其他坦克之后，子弹消失，被击中的玩家承受伤害；
    - `HandleCollisionWithWall(Wall* inWall)`：当子弹击中子弹墙之后，子弹消失。

#### 1.2. Wall Server

Wall Sever继承了Wall类。实现细节如下：

- 方法
    - `StaticCreate()`：创建墙壁。

#### 1.3. Tank Server

Tank Sever继承了Tank类。Tank的控制者可以从`ECatControlType`中进行选择，包括真人玩家或者AI控制。这个设计允许在参与人数不够的情况下，自动坦克的参与，增加了游戏趣味和可扩展性。

- 属性
    - `mCatControlType`：坦克的控制者——真人orAI；
    - `mTimeOfNextShot`：因为坦克不能过于频繁的射击子弹（*不然游戏会不公平*），所以需要定义最早可以的下次射击的时间；
    - `mTimeBetweenShots`：坦克两次射击之间的时间间隔（*间隔0.2s才可以发射下一颗子弹*）；
- 方法
    - `StaticCreate()`：创建坦克；
    - `HandleShooting()`：处理射击，如果发射子弹的间隔时间超过了0.2s，那么允许发射子弹；
    - `HandleDying()`：处理毁灭，当坦克被击中毁灭时，坦克服务器自动让坦克下线；
    - `Update()`：坦克更新，包括以下几部分：
        - 获取旧的坦克信息，包括位置、速度、角度；
        - 每间隔`deltaTime`与客户端交互一次，同步信息；
        - 根据HandleShooting()`方法处理射击；
        - 通过网络连接进行通信，完成数据的传输；
    - `TakeDamage()`：用来进承受伤害的控制，如果生命值小于0，设置坦克下线，否则生命值减1。

### 2. Client Proxy

客户端代理负责服务端和客户端的交互，主要支持对四种交流功能：包信息的交换、获得未处理的Movelist、设置Movelist的DirtyState、以及坦克的毁灭与重生。

- 属性
    - `mSocketAddress`：socket地址；
    - `mName`：客户端名字；
    - `mPlayerId`：玩家的ID
    - `mLastPacketFromClientTime`：最后一个传递的包；
    - `mTimeToRespawn`：下次重生的时间；
    - `mUnprocessedMoveList`：尚未处理的MoveList；
    - `mIsLastMoveTimestampDirty`：是否设定了DirtyState；
- 方法
    - `Get\*()`：各类获取函数；
    - `UpdateLastPacketTime()`：更新最后一个包时间；
    - `SetIsLastMoveTimestampDirty( bool inIsDirty )`：设置DirtyState；
    - `IsLastMoveTimestampDirty()`：是否设置过了DirtyState；
    - `HandleTankDied()`：处理坦克毁灭，这里的处理包括让坦克在`kRespawnDelay`后重生；
    - `ClientProxy::RespawnCatIfNecessary()`：创建新的坦克实例。

### 3. Manager Sever

管理服务器包括两个：复制管理服务器和网络管理服务器。其中，复制管理服务器用批量复制到机制保证了数据传输的可靠性；而网络管理服务器提供了客户端与服务端的网络连接，保证了两者交互的可能性，并在此实现了对象的注册和下线。以下是它们的详细介绍。

#### 3.1. Replication Manager Server

Replication Manager Server是Replication Manager的服务器，支持批量复制游戏中的请求——对于每一个对象都可以批量地创建、更新和删除所有属性。Replication Manager服务器的实现主要分为以下几个模块：

- 属性
    - `mNetworkIdToReplicationCommand`：需要复制请求信息的网络ID；
    - `mNetworkIdsToRemove`：需要删除请求信息的网络ID；
- 方法
    - `WriteCreateAction( OutputMemoryBitStream& inOutputStream, int inNetworkId, uint32_t inDirtyState )`：将一个游戏对象写入网络请求ID的包；
    - `WriteUpdateAction( OutputMemoryBitStream& inOutputStream, int inNetworkId, uint32_t inDirtyState )`：更新网络请求ID包中的游戏对象；
    - `WriteDestroyAction( OutputMemoryBitStream& inOutputStream, int inNetworkId, uint32_t inDirtyState )`：删除网络请求ID包中的游戏对象；
    - `ReplicateCreate( int inNetworkId, uint32_t inInitialDirtyState )`：建立对象复制，网络请求ID的复制命令根据复制命令的DirtyState确定；
    - `ReplicateDestroy( int inNetworkId )`：销毁网络请求ID的复制命令；
    - `RemoveFromReplication( int inNetworkId )`：将网络请求ID从需要复制命令的名单中除名；
    - `SetStateDirty( int inNetworkId, uint32_t inDirtyState )`：设置DirtyState，决定着网络请求的复制命令；
    - `Write( OutputMemoryBitStream& inOutputStream )`：写入复制命令是这个服务器的核心，主要包括以下几个部分：
        - 首先基于DirtyState，确定需要写入的复制命令是什么；
        - 然后明确处理的目标对象，也就是NetworkId；
        - 然后根据功能需要，创建、更新和删除动作；
        - 最后清除DirtyState。

#### 3.2. Network Manager Sever

Network Manager服务器提供了客户端与服务端的网络连接，支持两者之间的传包，并允许游戏中新对象的加入。实现的细节如下：

- 属性
    - `sInstance`：网络管理服务器实例；
    - `mAddressToClientMap`：客户端的身份；
    - `ToClientMapmPlayerIdToClientMap`：客户端的地址；
    - `mNewPlayerId`：新玩家的ID；
    - `mNewNetworkId`：新网络的ID；
    - `mTimeOfLastSatePacket`：上次传包的时间；
    - `mTimeBetweenStatePackets`：传包允许的时间；
    - `mClientDisconnectTimeout`：未连接到间隔；
- 方法
    - `RegisterAndReturn( GameObject* inGameObject )`：创建新的对象；
    - `ProcessPacket( InputMemoryBitStream& inInputStream, const SocketAddress& inFromAddress )`：处理包，包括寻找客户端代理、根据包分类（*有hello、input、和无效三种类型*）进行不同的处理；
    - `HandleConnectionReset( const SocketAddress& inFromAddress )`：重新设置连接；
    - `SendOutgoingPackets()`：向客户端发送一个状态包；
    - `CheckForDisconnects()`：检查是否连接中断了；
    - `RegisterGameObject( GameObjectPtr inGameObject )`：注册一个新的对象；
    - `UnregisterGameObject( GameObject* inGameObject )`：让一个对象下线；
    - `SetStateDirty( int inNetworkId, uint32_t inDirtyState )`：对某个网络ID设置DirtyState；
    - `RespawnTanks()`：让坦克复活；
    - `GetClientProxy( int inPlayerId )`：给玩家找网络代理。

### 4. ServerPCH

收集服务器整合所有需要的头文件，使代码结构更加有条理。整合需要的Inc包有：`TankWarShared.h`、`ReplicationManagerServer.h`、`ClientProxy.h`、`NetworkManagerServer.h`、`Server.h`、`TankServer.h`、`WallServer.h`、`BulletServer.h`。


### 5. Server

整合服务器包括以下功能：初始化网络功能、创建游戏世界、处理客户端事宜、为每个玩家分配坦克。具体实现如下：

- 方法
    - `Server()`：构造函数提供了服务器的初始化操作，包括以下功能模块：
        - 实例化坦克、子弹、墙壁；
        - 初始化网络管理器；
        - 设置延迟；
    - `InitNetworkManager()`：初始化网络管理器；
    - `SetupWorld()`：创建游戏世界，包括创造地图和对象的实例；
    - `DoFrame()`：定义了每一帧的行动，包括处理数据包、检查连接性、让坦克复活以及发送数据包；
    - `HandleNewClient( ClientProxyPtr inClientProxy )`：创建新的代理服务器；
    - `SpawnTankForPlayer( int inPlayerId )`：给玩家分配坦克；
    - `HandleLostClient( ClientProxyPtr inClientProxy )`：处理丢失的服务器代理；
    - `GetTankForPlayer( int inPlayerId )`：获取玩家的坦克；
    - - `Run()`：开始游戏。


## VI. 效果展示

《坦克大战》的玩家将会拥有良好的玩家体验，我们将我们的游戏demo放到了Youtube（[视频传输门](https://www.youtube.com/watch?v=itYok4eUv3A)）。

![](http://ww3.sinaimg.cn/large/006tNc79ly1g4ukrbnb9jg30rs0egx6q.gif)

![](http://ww4.sinaimg.cn/large/006tNc79ly1g4ukr9mxf7g30rs0egb2b.gif)

![](http://ww1.sinaimg.cn/large/006tNc79ly1g4ukr77t9lg30rs0egb2c.gif)

---

## VII. 参考资料

<!--ToDo: 参考资料-->

1. [《网络多人游戏架构与编程》](https://book.douban.com/subject/27135506/)

---
